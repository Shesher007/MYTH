// {{NAME}} Desktop â€” AES-256 Encrypted Local Storage (Feature 3)
// Protects saved reports, tokens, configs, and logs with AES-256-GCM.
// Key derived from OS user profile via machine-uid + PBKDF2.

use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};
use rand::RngCore;
use sha2::Sha256;
use pbkdf2::pbkdf2_hmac;
use base64::Engine;
use std::fs;
use std::path::PathBuf;
use log::info;

/// Salt for key derivation (should be app-specific constant)
const KDF_SALT: &[u8] = b"{{NAME}}_AES256_v1";
const KDF_ITERATIONS: u32 = 100_000;
const NONCE_SIZE: usize = 12;

/// Derive AES-256 key from machine fingerprint using PBKDF2-SHA256
fn derive_key() -> Result<[u8; 32], String> {
    let machine_id = machine_uid::get()
        .map_err(|e| format!("Failed to get machine ID: {}", e))?;

    let mut key = [0u8; 32];
    pbkdf2_hmac::<Sha256>(
        machine_id.as_bytes(),
        KDF_SALT,
        KDF_ITERATIONS,
        &mut key,
    );

    Ok(key)
}

/// Encrypt data with AES-256-GCM
fn encrypt_bytes(plaintext: &[u8]) -> Result<Vec<u8>, String> {
    let key = derive_key()?;
    let cipher = Aes256Gcm::new_from_slice(&key)
        .map_err(|e| format!("Cipher init failed: {}", e))?;

    let mut nonce_bytes = [0u8; NONCE_SIZE];
    OsRng.fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::from_slice(&nonce_bytes);

    let ciphertext = cipher
        .encrypt(nonce, plaintext)
        .map_err(|e| format!("Encryption failed: {}", e))?;

    // Prepend nonce to ciphertext for storage
    let mut output = nonce_bytes.to_vec();
    output.extend(ciphertext);
    Ok(output)
}

/// Decrypt data with AES-256-GCM
fn decrypt_bytes(encrypted: &[u8]) -> Result<Vec<u8>, String> {
    if encrypted.len() < NONCE_SIZE {
        return Err("Encrypted data too short".to_string());
    }

    let key = derive_key()?;
    let cipher = Aes256Gcm::new_from_slice(&key)
        .map_err(|e| format!("Cipher init failed: {}", e))?;

    let (nonce_bytes, ciphertext) = encrypted.split_at(NONCE_SIZE);
    let nonce = Nonce::from_slice(nonce_bytes);

    cipher
        .decrypt(nonce, ciphertext)
        .map_err(|e| format!("Decryption failed (wrong machine or corrupted data): {}", e))
}

/// Get the encrypted storage directory
fn get_storage_dir() -> Result<PathBuf, String> {
    let base = dirs::data_local_dir()
        .ok_or_else(|| "Cannot resolve local data directory".to_string())?;
    let dir = base.join("{{NAME}}").join("encrypted");
    fs::create_dir_all(&dir)
        .map_err(|e| format!("Cannot create storage dir: {}", e))?;
    Ok(dir)
}

/// Tauri IPC: Encrypt arbitrary string data
#[tauri::command]
pub fn encrypt_data(plaintext: String) -> Result<String, String> {
    let encrypted = encrypt_bytes(plaintext.as_bytes())?;
    Ok(base64::engine::general_purpose::STANDARD.encode(&encrypted))
}

/// Tauri IPC: Decrypt string data
#[tauri::command]
pub fn decrypt_data(encrypted_b64: String) -> Result<String, String> {
    let encrypted = base64::engine::general_purpose::STANDARD
        .decode(&encrypted_b64)
        .map_err(|e| format!("Base64 decode failed: {}", e))?;
    let decrypted = decrypt_bytes(&encrypted)?;
    String::from_utf8(decrypted).map_err(|e| format!("UTF-8 decode failed: {}", e))
}

/// Tauri IPC: Save encrypted data to a file in local storage
#[tauri::command]
pub fn save_encrypted_file(filename: String, data: String) -> Result<bool, String> {
    let dir = get_storage_dir()?;
    let encrypted = encrypt_bytes(data.as_bytes())?;
    let path = dir.join(&filename);
    fs::write(&path, &encrypted)
        .map_err(|e| format!("Write failed: {}", e))?;
    info!("ðŸ” [CRYPTO] Saved encrypted file: {}", filename);
    Ok(true)
}

/// Tauri IPC: Load and decrypt data from local encrypted storage
#[tauri::command]
pub fn load_encrypted_file(filename: String) -> Result<String, String> {
    let dir = get_storage_dir()?;
    let path = dir.join(&filename);

    if !path.exists() {
        return Err(format!("Encrypted file not found: {}", filename));
    }

    let encrypted = fs::read(&path)
        .map_err(|e| format!("Read failed: {}", e))?;
    let decrypted = decrypt_bytes(&encrypted)?;

    String::from_utf8(decrypted).map_err(|e| format!("UTF-8 decode failed: {}", e))
}
